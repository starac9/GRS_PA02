# MT25062

# README - PA02: Analysis of Network I/O Primitives using "perf" Tool

# Roll No: MT25062

# Course: CSE638 - Graduate Systems

## Overview

This project implements and compares three TCP-based client-server communication
strategies to study the cost of data movement in network I/O:

1. **Two-Copy (A1):** Baseline using `send()` / `recv()` with manual serialization.
2. **One-Copy (A2):** Optimized using `sendmsg()` with scatter-gather I/O (`iovec`).
3. **Zero-Copy (A3):** Using `sendmsg()` with `MSG_ZEROCOPY` flag.

Each implementation uses a multithreaded architecture with parameterized message
sizes and thread counts. Profiling is done using the Linux `perf` tool.

## File Listing

| File                           | Description                                           |
| ------------------------------ | ----------------------------------------------------- |
| `MT25062_Part_A1_Server.c`     | Two-copy server (recv-based, standalone)              |
| `MT25062_Part_A1_Client.c`     | Two-copy client (serialize + send, standalone)        |
| `MT25062_Part_A2_Server.c`     | One-copy server (recv-based, standalone)              |
| `MT25062_Part_A2_Client.c`     | One-copy client (sendmsg with iovec, standalone)      |
| `MT25062_Part_A3_Server.c`     | Zero-copy server (recv-based, standalone)             |
| `MT25062_Part_A3_Client.c`     | Zero-copy client (sendmsg + MSG_ZEROCOPY, standalone) |
| `MT25062_Part_C_Experiment.sh` | Automated experiment runner script                    |
| `MT25062_Part_D_Plots.py`      | Matplotlib plotting script (hardcoded values)         |
| `MT25062_Part_B_Results.csv`   | Raw CSV data (generated by experiment script)         |
| `Makefile`                     | Build system                                          |
| `README`                       | This file                                             |

## Prerequisites

- Linux system with kernel >= 4.14 (for MSG_ZEROCOPY support)
- GCC compiler
- `perf` tool (`sudo apt install linux-tools-common linux-tools-$(uname -r)`)
- Python 3 with matplotlib (`pip3 install matplotlib numpy`)
- Root privileges (for network namespaces and perf)

## Building

```bash
make all        # Build all implementations
make a1         # Build two-copy only
make a2         # Build one-copy only
make a3         # Build zero-copy only
make clean      # Remove all binaries
```

## Running Individual Experiments

### 1. Set Up Network Namespaces

```bash
# Create namespaces
sudo ip netns add ns_server
sudo ip netns add ns_client

# Create veth pair
sudo ip link add veth_srv type veth peer name veth_cli
sudo ip link set veth_srv netns ns_server
sudo ip link set veth_cli netns ns_client

# Configure IPs
sudo ip netns exec ns_server ip addr add 10.0.0.1/24 dev veth_srv
sudo ip netns exec ns_client ip addr add 10.0.0.2/24 dev veth_cli
sudo ip netns exec ns_server ip link set veth_srv up
sudo ip netns exec ns_server ip link set lo up
sudo ip netns exec ns_client ip link set veth_cli up
sudo ip netns exec ns_client ip link set lo up

# Verify
sudo ip netns exec ns_client ping -c 1 10.0.0.1
```

### 2. Run Server and Client

```bash
# Terminal 1: Start server in server namespace
sudo ip netns exec ns_server ./a1_server 8080

# Terminal 2: Run client in client namespace
sudo ip netns exec ns_client ./a1_client 10.0.0.1 8080 4096 4 10
```

Client arguments: `<server_ip> <port> <msg_size> <threads> <duration>`

### 3. Profile with perf

```bash
sudo ip netns exec ns_client perf stat \
    -e cycles,cache-references,cache-misses,L1-dcache-load-misses,LLC-load-misses,context-switches \
    ./a1_client 10.0.0.1 8080 4096 4 10
```

### 4. Cleanup Namespaces

```bash
sudo ip netns del ns_server
sudo ip netns del ns_client
```

## Running Automated Experiments (Part C)

```bash
sudo bash MT25062_Part_C_Experiment.sh
```

This script automatically:

- Compiles all implementations
- Sets up network namespaces
- Runs experiments for all combinations of message sizes and thread counts
- Collects perf profiling data
- Writes results to `MT25062_Part_B_Results.csv`
- Cleans up namespaces on exit

## Generating Plots (Part D)

```bash
python3 MT25062_Part_D_Plots.py
```

**Important:** Before running, update the hardcoded data arrays in the Python script
with your actual experimental results from the CSV file.

## Message Structure

The message comprises 8 dynamically allocated string fields:

```c
typedef struct {
    char *fields[8];    // 8 heap-allocated string fields
    int   field_size;   // Size of each field = msg_size / 8
} message_t;
```

Each field is allocated via `malloc()` and filled with a pattern character.

## Copy Analysis

### A1: Two-Copy

- **Copy 1 (User-space):** 8 scattered fields serialized via `memcpy()` into
  a contiguous send buffer.
- **Copy 2 (Kernel):** `send()` copies the contiguous buffer into the kernel
  socket buffer (`sk_buff`).

### A2: One-Copy

- **Eliminated:** User-space serialization copy. The `iovec` array points
  directly to each field's heap allocation.
- **Remaining (Kernel):** `sendmsg()` copies from scattered user buffers
  (via iovec) into the kernel socket buffer.

### A3: Zero-Copy

- **Eliminated:** Both user-space and kernel copies.
- **Mechanism:** Kernel pins user-space pages via `get_user_pages()` and
  creates `sk_buff` fragments pointing directly to user memory. The NIC
  DMA engine reads from user pages. Completion notifications are sent
  via the socket error queue (`SO_EE_ORIGIN_ZEROCOPY`).

## GitHub Repository

URL: (Add your public GitHub repo URL here)
Folder: GRS_PA02
